<possible outcome>	
ship activation	3	
squadron activation	10	
=> 13

choose command	4	
command token conversion	1	bool
squadron command	1	bool
engineering command	1	bool
engineering point spend	17	< move 4 * 3 + recover 4 + repair 1 (ignore critical)

set attacking hull	4	
set target	13	< squadron or ship hull 12
add dice	3	1
reroll dice	12	< each dice with eye
spend accuracy	6	< each type, is exhausted
set attacking hull	4	
set target	13	< squadron or ship hull 12
add dice	3	
reroll dice	12	< each dice with eye
spend accuracy	6	< each type, is exhausted
spend defense token	6	< each type, is exhausted (player switch)


decide maneuver	6	< with caution, each speed joint
=>

squadron speed	10	< 0.5 distance
squadron direction	20	< 30deg (hmm... )
squadron set target	22	< ship hull 12 + squad 10

1. ship activation
2. set target
3. maneuver (+- 1)

no squad, no command, no attack sequence








=====================

    def _execute_mcts_turn(self, iterations : int = 1000):
        """
        Executes a full ship activation for the MCTS player by breaking it down
        into sequential decisions.
        """
        # === 1. CHOOSE SHIP TO ACTIVATE ===
        with open('simulation_log.txt', 'a') as f: f.write(f"\nPlayer {self.current_player} is thinking about phase: activation")
        state : MCTSState = {
            "game": self, 
            "current_player": self.current_player, 
            "decision_phase": "ship_activation",
            "active_ship_id": None, 
            "declare_target": None,
            "course": None
            }
        mcts_state_copy = copy.deepcopy(state)
        mcts_state_copy['game'].simulation_mode = True
        mcts = MCTS(initial_state=mcts_state_copy, player=self.current_player)
        mcts.search(iterations=iterations)
        action = mcts.get_best_action()

        if action is None or action[0] != 'activate_ship_action':
            raise ValueError('MCTS must choose ship to activate')
        
        active_ship_id : int = action[1]
        active_ship = self.ships[active_ship_id]
        with open('simulation_log.txt', 'a') as f: f.write(f"\nPlayer {self.current_player} chose action: {action[0], active_ship.name}")


        # === 2. ATTACK PHASE ===

        while active_ship.attack_count < 2 :
            with open('simulation_log.txt', 'a') as f: f.write(f"\nPlayer {self.current_player} is thinking about attack #{active_ship.attack_count + 1}...")
            

            state : MCTSState = {
                "game": self, 
                "current_player": self.current_player, 
                "decision_phase": "declare_target", 
                "active_ship_id": active_ship_id, 
                "declare_target": None,
                "course": None,
                }
            mcts_state_copy = copy.deepcopy(state)
            mcts_state_copy['game'].simulation_mode = True
            mcts = MCTS(initial_state=mcts_state_copy, player=self.current_player)
            mcts.search(iterations=iterations)
            action = mcts.get_best_action()

            # If the AI decides to skip, break the attack loop
            if action is None or (action[0] != 'declare_target_action' and action[0] != 'pass_attack'):
                raise ValueError('MCTS must choose declare target or pass to maneuver')
            if action[0] == 'pass_attack':
                with open('simulation_log.txt', 'a') as f: f.write(f"\nPlayer {self.current_player} skips to move ship step")
                break

            with open('simulation_log.txt', 'a') as f: f.write(f"\nPlayer {self.current_player} has decided to attack. Determining optimal target...")
            if action[1] is None :
                raise ValueError('Action must contain target information')

            # Decode the optimal attack path
            attacking_hull = action[1][0]
            defend_ship = self.ships[action[1][1]]
            defending_hull = action[1][2]

            # Execute the chosen attack in the REAL game
            with open('simulation_log.txt', 'a') as f: f.write(f"\nPlayer {self.current_player} executes optimal attack: {active_ship.name} ({attacking_hull.name}) -> {defend_ship.name} ({defending_hull.name})")
            
            # Roll the dice and resolve the attack in the actual game state
            attack_pool = active_ship.roll_attack_dice(attacking_hull, defend_ship, defending_hull)
            if attack_pool:
                active_ship.resolve_damage(defend_ship, defending_hull, attack_pool)



        # # === 3. MOVE SHIP PHASE ===
        # with open('simulation_log.txt', 'a') as f: f.write(f"\nPlayer {self.current_player} is thinking about the full maneuver...")

        # # 1. Set up the initial state
        # state : MCTSState = {
        #     "game": self,
        #     "current_player": self.current_player,
        #     "decision_phase": "determine_course",
        #     "active_ship_id": active_ship_id,
        #     "declare_target": None,
        #     "course": None
        #     }
        # mcts_state_copy = copy.deepcopy(state)
        # mcts_state_copy['game'].simulation_mode = True

        # # 2. Create and run MCTS
        # mcts = MCTS(initial_state=mcts_state_copy, player=self.current_player)
        # mcts.search(iterations=iterations)

        # action = mcts.get_best_action()
        # if action is None or action[0] != 'determine_course_action' :
        #     raise ValueError('MCTS must choose course')
        
        # course = action[1][0]
        # placement = action[1][1]
        # active_ship.speed = len(course)

        # with open('simulation_log.txt', 'a') as f: f.write(f"\nPlayer {self.current_player} chose final maneuver: Course {course}, Placement {'left' if placement == -1 else 'right'}")
        # active_ship.move_ship(course, placement)


        # === 3. HIERARCHICAL MANEUVER PHASE (Single Search, Walk Down) ===
        with open('simulation_log.txt', 'a') as f: f.write(f"\nPhase: Maneuver Planning")
        state = {
            "game": self, "current_player": self.current_player, "decision_phase": "determine_speed",
            "active_ship_id": active_ship_id, "declare_target": None, "course": None
        }
        mcts_state_copy = copy.deepcopy(state)
        mcts_state_copy['game'].simulation_mode = True
        mcts = MCTS(initial_state=mcts_state_copy, player=self.current_player)
        mcts.search(iterations=iterations)


        # --- Walk down the tree to get the full maneuver ---
        # Get Speed
        best_node = mcts.get_best_child()
        with open('simulation_log.txt', 'a') as f: f.write(f"\nTotal Win {round(best_node.wins)}. Best Action {best_node.action} \n{[(node.action, round(node.wins), node.visits) for node in best_node.children]}")

        speed_action = best_node.action
        if speed_action is None or speed_action[0] != 'determine_speed_action': raise ValueError("MCTS failed to return a speed action.")
        speed = speed_action[1]
        active_ship.speed = speed

        course = []
        if speed > 0:
            # Get Yaws by walking down the tree
            for joint_index in range(speed):
                best_node = max(best_node.children, key=lambda c: c.visits)
                with open('simulation_log.txt', 'a') as f: f.write(f"\nTotal Win {round(best_node.wins)}. Best Action {best_node.action} \n{[(node.action, round(node.wins), node.visits) for node in best_node.children]}")
                
                yaw_action = best_node.action
                if yaw_action is None or yaw_action[0] != 'determine_yaw_action': raise ValueError("MCTS failed to return a yaw action.")
                course.append(yaw_action[1])

            # Get Placement
            best_node = max(best_node.children, key=lambda c: c.visits)
            with open('simulation_log.txt', 'a') as f: f.write(f"\nTotal Win {round(best_node.wins)}. Best Action {best_node.action} \n{[(node.action, round(node.wins), node.visits) for node in best_node.children]}")
            placement_action = best_node.action
            if placement_action is None or placement_action[0] != 'determine_placement_action': raise ValueError("MCTS failed to return a placement action.")
            placement = placement_action[1]
        else:
            placement = 1 # Default placement for speed 0
        
        placement_str = 'left' if placement == -1 else 'right'

        # --- Execute the final maneuver ---
        with open('simulation_log.txt', 'a') as f: f.write(f"\nAction: Execute Maneuver {course, placement_str}")
        active_ship.move_ship(course, placement)
        

        # End of activation
        active_ship.activated = True




    def _execute_random_activation(self, ship_to_activate: Ship):
        """
        Executes a full, random activation for a given ship (for the non-MCTS player).
        """
        
        # 1. Attack Phase
        while ship_to_activate.attack_count < 2:
            valid_hulls = ship_to_activate.get_valid_attack_hull()
            if not valid_hulls: break
            
            attack_hull = random.choice(valid_hulls)
            defend_ship = random.choice(ship_to_activate.get_valid_target_ship(attack_hull))
            defend_hull = random.choice(ship_to_activate.get_valid_target_hull(attack_hull, defend_ship))
            attack_pool = ship_to_activate.roll_attack_dice(attack_hull, defend_ship, defend_hull)
            if attack_pool:
                ship_to_activate.resolve_damage(defend_ship, defend_hull, attack_pool)


        # 2. Maneuver Phase
        valid_speed = ship_to_activate.get_valid_speed()
        speed = random.choice(valid_speed)
        ship_to_activate.speed = speed

        course = []
        for joint in range(speed):
            valid_yaw = ship_to_activate.get_valid_yaw(speed, joint)
            yaw = random.choice(valid_yaw)
            course.append(yaw - 2)
        
        if speed > 0:
            valid_placement = ship_to_activate.get_valid_placement(course)
            placement = random.choice(valid_placement)
            ship_to_activate.move_ship(course, placement)
        
        ship_to_activate.activated = True